{-# LANGUAGE OverloadedStrings, LambdaCase #-}
-- | Module that builds a Markov chain from chat messages and responds to
--   questions using sentences generated by that chain.
module Kagamin.Modules.Markov (kagaMarkov) where
import Kagamin.Modules
import Kagamin.TextUtils
import Control.Concurrent.MVar
import Control.Exception (SomeException (..), try)
import Control.Monad.State (MonadIO (..), get)
import qualified Data.Text as T
import Web.Slack
import qualified Web.Slack.Message (sendMessage)
import System.Random (newStdGen, randomIO, randomRIO)
import DissociatedPress
import Data.List (foldl')
import Data.Text.Binary ()
import qualified Data.Map.Strict as M
import Text.Zalgo
import KagaInfo (kagaID)

data MarkovState = MarkovState
  { aliases    :: !(M.Map T.Text T.Text)
  , dictionary :: !(Dictionary T.Text)
  }

sendMessage :: ChannelId -> T.Text -> Slack t ()
sendMessage cid message = do
  msg' <- liftIO $ redactIO deletedGirls msg
  msg'' <- case () of
    () | msg /= msg' -> do
           pure msg'
       | "monika" `T.isInfixOf` message -> do
           liftIO $ zalgoIOWith weak msg
       | otherwise -> do
           liftIO $ randomRIO (0, 100 :: Int) >>= \case
             100 -> monika $ init $ init msg
             99  -> gradualZalgoIO 0.7 msg
             98  -> zalgoIOWith weak msg
             _   -> return msg
  Web.Slack.Message.sendMessage cid (T.pack msg'')
  where
    msg = T.unpack message
    deletedGirls = ["Natsuki","natsuki","NATSUKI","Sayori","sayori","SAYORI"]
    monika s = gradualZalgoIO 0.5 $ (s ++ "O N L Y M O N I K A")
    weak = defaultZalgoSettings
      { maxHeightAt = const 2
      , varianceAt  = const 1
      }

kagaMarkov :: IO KagaModule
kagaMarkov = do
  state <- newMVar $ MarkovState M.empty defDict
  return $ defaultModule {
      kagaMsgHook   = handleKagaMsg state,
      kagaOtherHook = handleOtherMsg state,
      kagaSaveHook  = save state,
      kagaLoadHook  = Kagamin.Modules.Markov.load state
    }

save :: MVar MarkovState -> FilePath -> IO ()
save v dir = withMVar v $ \st -> do
  store (dir ++ "/kagamin.dict") (dictionary st)
  writeFile (dir ++ "/kagamin.markov-aliases") $ show (aliases st)

load :: MVar MarkovState -> FilePath -> IO ()
load v dir = do
  olddict <- dictionary <$> takeMVar v
  dict <- DissociatedPress.load $ dir ++ "/kagamin.dict"
  alias <- try $! do
    lst <- read <$> readFile (dir ++ "/kagamin.markov-aliases")
    length lst `seq` return lst
  let alias' = case alias of
        Left (SomeException _) -> M.empty
        Right a                -> a
  putMVar v $ MarkovState alias' (maybe olddict id dict)

setAlias :: MVar MarkovState -> UserId -> T.Text -> Slack () ()
setAlias v (Id uid) alias = liftIO $ modifyMVar v $ \st -> do
  pure (st {aliases = M.insert uid alias (aliases st)}, ())

getAlias :: MVar MarkovState -> UserId -> Slack () T.Text
getAlias v (Id uid) =
  liftIO $ withMVar v (return . maybe uid id . M.lookup uid . aliases)

applyAliases :: [User] -> M.Map T.Text T.Text -> T.Text -> T.Text
applyAliases users aliasmap msg =
    T.replace "<!channel>" "kanalen" $
      foldl' applyAliasNick (M.foldlWithKey' applyAlias msg aliasmap) users
  where
    applyAliasNick m user
      | Just alias <- M.lookup (unId $ _userId user) aliasmap =
        T.replace (_userName user) alias m
      | otherwise =
        m
    unId (Id x) = x
    mkTag uid = T.concat ["<@", uid, ">"]
    applyAlias m uid alias = T.replace (mkTag uid) alias m

sendAliased :: MVar MarkovState -> ChannelId -> T.Text -> Slack () ()
sendAliased v cid s = do
  users <- (_slackUsers . _session) <$> get
  st <- liftIO $ withMVar v return
  sendMessage cid (applyAliases users (aliases st) s)

handleKagaMsg :: MVar MarkovState -> MsgHook
handleKagaMsg v cid from msg
  | "kalla mig" `T.isPrefixOf` msg'
  , UserComment uid <- from = do
    let alias = T.strip $ dropPrefix "kalla mig" msg'
    setAlias v uid alias
    reportAliasChange cid alias
    return Next
  | "vad är" `T.isPrefixOf` msg' = do
    st <- liftIO $ withMVar v return
    let d = dictionary st
        q = T.strip $ dropPrefix "vad är" $ dropSuffix "?" msg'
    quote <- ask q d <$> liftIO newStdGen
    if T.null quote
      then dontKnow cid
      else sendAliased v cid quote
    return Next
  | "citat" == msg' = do
    st <- liftIO $ withMVar v return
    let d = dictionary st
    quote <- randomSentence d <$> liftIO newStdGen
    sendAliased v cid quote
    return Next
  | "vem är jag" `T.isPrefixOf` msg'    = reportAlias v cid from
  | "vad heter jag" `T.isPrefixOf` msg' = reportAlias v cid from
  | otherwise = do
    return Next
  where
    msg' = stripLeadingTrailingMention kagaID msg

reportAlias :: MVar MarkovState -> ChannelId -> Submitter -> Slack () HookResult
reportAlias v cid (UserComment uid) = do
  pfx <- oneOf
    [ "är du senil?"
    , "är du dum?"
    , "mår du bra?"
    ]
  alias <- getAlias v uid
  maybeStutter (T.concat [pfx, " du heter ju ", alias]) >>= sendMessage cid
  return Next
reportAlias _ _ _ = do
  return Next


handleOtherMsg :: MVar MarkovState -> MsgHook
handleOtherMsg v _cid _from msg
  | Just _ <- extractUrl msg = do
    return Next -- ignore URLs
  | otherwise                = do
    liftIO $ modifyMVar v $ \st -> do
      let d = dictionary st
      return (st {dictionary = updateDict (T.words msg) d}, Next)

dontKnow :: ChannelId -> Slack s ()
dontKnow cid = do
  msg <- oneOf
    [ "hur ska jag kunna veta det?!"
    , "idiotfråga!!"
    , "varför skulle jag svara på dina frågor?!"
    , "idiot!"
    , "jag är inte din googleslav!"
    , "skärp dig!"
    ]
  maybeStutter msg >>= sendMessage cid

reportAliasChange :: ChannelId -> T.Text -> Slack s ()
reportAliasChange cid alias = do
  msg <- oneOf
    [ T.concat ["ok, då kallar jag dig för ", alias, "... senpai"]
    , T.concat ["ok ", alias]
    , T.concat [alias, " är ett fjantnamn, men ok då"]
    , T.concat ["ok då ", alias, "... men det är inte för att jag gillar dig eller så!"]
    ]
  maybeStutter msg >>= sendMessage cid

maybeStutter :: T.Text -> Slack s T.Text
maybeStutter msg = do
  st <- liftIO randomIO
  pure $ if st then stutter msg else msg

oneOf :: MonadIO m => [a] -> m a
oneOf xs = do
  ix <- liftIO $ randomRIO (0, length xs-1)
  return $ xs !! ix
